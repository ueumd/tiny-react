<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>Document</title>
	</head>
	<body>
		<div id="root">
			<h1>这是一个h1</h1>
			<div>这是第 1 个 div 标签</div>
			<div>这是第 2 个 div 标签</div>
			<h3 class="h3">这是1个h3</h3>
			<div class="box">box</div>
			<ul>
				<li>li 1</li>
				<li>li 2</li>
				<li>li 3</li>
			</ul>
		</div>

		<div>
			<button onclick="add()">添加一个元素</button>
			<button onclick="insert()">h3前面插入元素</button>
			<button onclick="remove()">删除box</button>
			<button onclick="removeAll()">删除全部元素</button>
		</div>
		<script>
			const root = document.getElementById('root')

			function add() {
				const node = document.createElement('h1')
				node.textContent = '插入了1个h1标签'
				root.appendChild(node)
				console.log(root)
			}

			function insert() {
				const h3 = document.querySelector('.h3')
				const node = document.createElement('div')
				node.textContent = '这是在h3标签前面插入的元素'
				root.insertBefore(node, h3)
			}

			function remove() {
				const box = document.querySelector('.box')
				box.remove()
			}

			function removeAll() {}

			console.log(root.children)
			/**
			    HTMLCollection(6) [h1, div, div, h3.h3, div.box, ul]
			    0: h1
			    1: div
			    2: div
			    3: h3.h3
			    4: div.box
			    5: ul
			    */

			console.log(root.childNodes)
			/**
			    这里的childNodes 包含了 \t \n等转义字符
			    0: text
			    1: h1
			    2: text
			    3: div
			    4: text
			    5: div
			    6: text
			    7: h3.h3
			    8: text
			    9: div.box
			    10: text
			    11: ul
			    12: text
			    */

			class VNode {
				constructor(tag, data, value, type) {
					this.tag = tag && tag.toLowerCase()
					this.data = data
					this.value = value
					this.type = type
					this.children = []
				}
				appendChild(vNode) {
					this.children.push(vNode)
				}
			}

			/**
       利用递归 来遍历DOM元素 生成虚拟DOM
       Vue中的源码使用 栈结构  ，使用栈存储 父元素来实现递归生成
       */
			function getVNode(node) {
				let nodeType = node.nodeType
				let _vnode = null

				if (nodeType === 1) {
					// 元素
					let nodeName = node.nodeName //元素名 什么标签？
					let attrs = node.attributes //属性  伪数组 元素上的属性
					let _attrObj = {}

					for (let i = 0; i < attrs.length; i++) {
						//attrs[ i ] 属性节点（nodeType == 2) 是对象
						_attrObj[attrs[i].nodeName] = attrs[i].nodeValue //attrs[ i ].nodeName:属性名 attrs[ i ].nodeValue：属性值
					}
					_vnode = new VNode(nodeName, _attrObj, undefined, nodeType) //标签名（DIV UI LI...）、所有属性对象、value值（只有文本标签有）、type类型(是元素还是文本)
					// 考虑node的子元素
					let childNodes = node.childNodes
					for (let i = 0; i < childNodes.length; i++) {
						_vnode.appendChild(getVNode(childNodes[i])) //递归
					}
				} else if (nodeType === 3) {
					// 文本节点
					_vnode = new VNode(undefined, undefined, node.nodeValue, nodeType) //无标签名、无属性、有value、有type
				}
				return _vnode
			}

			// 将vNode转化为真正的DOM
			function parseNode(vnode) {
				// 在真正的vue中 也是使用递归+栈 数据类型
				// 创建真实的DOM
				let type = vnode.type //拿到虚拟DOM的type,元素？文本？
				let _node = null //用来放创建出来的元素  真实node
				if (type === 3) {
					// 文本节点
					return document.createTextNode(vnode.value) //直接创建文本节点
				} else if (type === 1) {
					// 元素节点
					_node = document.createElement(vnode.tag) //用tag名创建对应的标签

					// 属性
					let data = vnode.data //键值对类型  真正的vue中药比这复杂的多（事件、指令等）
					Object.keys(data).forEach(key => {
						let attrName = key //属性名
						let attrValue = data[key] //属性值
						_node.setAttribute(attrName, attrValue) //社会元素的属性
					})
					// 子元素
					let children = vnode.children
					children.forEach(subvnode => {
						_node.appendChild(parseNode(subvnode)) //将子元素放进去  递归转换子元素
					})
					return _node
				}
			}

      const vDOM = getVNode(root)
			console.log(vDOM)

			let dom2 = parseNode(vDOM) //虚拟dom转换成真实dom
			console.log(dom2) //打印出来的DOM和真实dom是一样的
		</script>
	</body>
</html>
